<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="C和C++语法总结, Ace 自然语言处理 深度学习">
    <meta name="baidu-site-verification" content>
    <meta name="google-site-verification" content>
    <meta name="360-site-verification" content>
    <meta name="description" content="一、C语言篇1、gcc/g++1.1、为什么需要gcc/g++
编辑器(如vi、记事本)是指我用它来写程序的（编辑代码），而我们写的代码语句，电脑是不懂的，我们需要把它转成电脑能懂的语句，编译器就是这样的转化工具。就是说，我们用编辑器编写程">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>C和C++语法总结 | 杨青海的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">杨青海的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">杨青海的博客</div>
        <div class="logo-desc">
            
            计算机科学与技术 | 计算机视觉
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/981935539" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/981935539" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        C和C++语法总结
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/C/" target="_blank">
                            <span class="chip bg-color">C++</span>
                        </a>
                        
                        <a href="/tags/C/" target="_blank">
                            <span class="chip bg-color">C</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/C/" class="post-category" target="_blank">
                            C++
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-01-03
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    Ace
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    34 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="一、C语言篇"><a href="#一、C语言篇" class="headerlink" title="一、C语言篇"></a>一、C语言篇</h1><h2 id="1、gcc-g"><a href="#1、gcc-g" class="headerlink" title="1、gcc/g++"></a>1、gcc/g++</h2><p><strong>1.1、为什么需要gcc/g++</strong></p>
<p>编辑器(如vi、记事本)是指我用它来写程序的（编辑代码），而我们写的代码语句，电脑是不懂的，我们需要把它转成电脑能懂的语句，编译器就是这样的转化工具。就是说，<strong>我们用编辑器编写程序，由编译器编译后才可以运行！</strong></p>
<p><strong>1.2、gcc编译器介绍</strong></p>
<p>编译器是将易于编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低级机器语言的程序。</p>
<p>gcc（GNU Compiler Collection，GNU 编译器套件），是由 GNU 开发的编程语言编译器。gcc原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，gcc同样适用于微软的Windows。</p>
<p>gcc最初用于编译C语言，随着项目的发展gcc已经成为了能够编译C、C++、Java、Ada、fortran、Object C、Object C++、Go语言的编译器大家族。</p>
<p>gcc最初用于编译C语言，随着项目的发展gcc已经成为了能够编译C、C++、Java、Ada、fortran、Object C、Object C++、Go语言的编译器大家族。</p>
<p><strong>1.3、编译命令</strong></p>
<p>编译命令格式：</p>
<p>gcc [-option1] … <filename></filename></p>
<p>g++ [-option1] … <filename></filename></p>
<ul>
<li><p>命令、选项和源文件之间使用空格分隔</p>
</li>
<li><p>一行命令中可以有零个、一个或多个选项</p>
</li>
<li><p>文件名可以包含文件的绝对路径，也可以使用相对路径</p>
</li>
<li><p>如果命令中不包含输出可执行文件的文件名，可执行文件的文件名会自动生成一个默认名，Linux平台为<strong>a.out</strong>，Windows平台为<strong>a.exe</strong></p>
</li>
</ul>
<p>gcc、g++编译常用选项说明：</p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-o file</td>
<td>指定生成的输出文件名为file</td>
</tr>
<tr>
<td>-E</td>
<td>只进行预处理</td>
</tr>
<tr>
<td>-S(大写)</td>
<td>只进行预处理和编译</td>
</tr>
<tr>
<td>-c(小写)</td>
<td>只进行预处理、编译和汇编</td>
</tr>
</tbody></table>
<p><strong>1.4、gcc/g++的区别</strong></p>
<ol>
<li><p>gcc与g++都可以编译c代码和c++代码, 但是: 后缀为.c的，gcc会把它当做C程序, 而g++当做是C++程序; 后缀为.cpp的，两者都会认为是C++程序.</p>
</li>
<li><p>编译阶段，可以使用gcc/g++, g++会自动调用gcc。而链接阶段,可以用g++或者gcc -lstdc++</p>
<p>,因为gcc命令不能自动和c++程序使用的库链接，通常用g++来完成。</p>
</li>
</ol>
<h2 id="2、C-C-编译过程"><a href="#2、C-C-编译过程" class="headerlink" title="2、C/C++编译过程"></a>2、C/C++编译过程</h2><p><strong>2.1、编译步骤</strong></p>
<p>C代码编译成可执行程序经过4步：</p>
<p>1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法</p>
<p>2)   编译：检查语法，将预处理后文件编译生成汇编文件</p>
<p>3）汇编：将汇编文件生成目标文件(二进制文件)</p>
<p>4）链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去</p>
<p><img src="file:////tmp/wps-yang-pc/ksohtml/wpsOWVxwY.jpg" alt="img"></p>
<p><strong>2.2、gcc编译过程</strong></p>
<p>1) 分步编译</p>
<p>预处理：<code>gcc -E hello.c -o hello.i</code></p>
<p>编  译：<code>gcc -S hello.i -o hello.s</code></p>
<p>汇  编：<code>gcc -c hello.s -o hello.o</code></p>
<p>链  接：<code>gcc   hello.o -o hello_elf</code></p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-E</td>
<td>只进行预处理</td>
</tr>
<tr>
<td>-S(大写)</td>
<td>只进行预处理和编译</td>
</tr>
<tr>
<td>-c(小写)</td>
<td>只进行预处理、编译和汇编</td>
</tr>
<tr>
<td>-o file</td>
<td>指定生成的输出文件名为 file</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong><em>\</em>文件后缀**</strong></th>
<th><strong><em>\</em>含义**</strong></th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>C 语言文件</td>
</tr>
<tr>
<td>.i</td>
<td>预处理后的 C 语言文件</td>
</tr>
<tr>
<td>.s</td>
<td>编译后的汇编文件</td>
</tr>
<tr>
<td>.o</td>
<td>编译后的目标文件</td>
</tr>
</tbody></table>
<p>2) 一步编译</p>
<p><code>gcc hello.c -o demo</code></p>
<p><strong>2.3、查找程序所依赖的动态库</strong></p>
<p>１）Linux平台下，<code>ldd</code>(“l”为字母) 可执行程序</p>
<p>２）Windows平台下，需要相应软件(<code>Depends.exe</code>)</p>
<h2 id="3、CPU内部结构与寄存器"><a href="#3、CPU内部结构与寄存器" class="headerlink" title="3、CPU内部结构与寄存器"></a>3、CPU内部结构与寄存器</h2><h3 id="3-1、CPU总线"><a href="#3-1、CPU总线" class="headerlink" title="3.1、CPU总线"></a>3.1、CPU总线</h3><p><strong>数据总线</strong></p>
<p>（1） 是CPU与内存或其他器件之间的数据传送的通道。</p>
<p>（2）数据总线的宽度决定了CPU和外界的数据传送速度。</p>
<p>（3）每条传输线一次只能传输1位二进制数据。eg: 8根数据线一次可传送一个8位二进制数据(即一个字节)。</p>
<p>（4）数据总线是数据线数量之和。</p>
<p>数据总线数据总线是CPU与存储器、CPU与I/O接口设备之间传送数据信息(各种指令数据信息)的总线，这些信号通过数据总线往返于CPU与存储器、CPU与I/O接口设备之间，因此，数据总线上的信息是双向传输的。</p>
<p><strong>地址总线</strong></p>
<p>（1）CPU是通过地址总线来指定存储单元的。</p>
<p>（2）地址总线决定了cpu所能访问的最大内存空间的大小。eg: 10根地址线能访问的最大的内存为1024位二进制数据（1024个内存单元）(1B)</p>
<p>（3）地址总线是地址线数量之和。</p>
<p>地址总线（Address Bus）是一种计算机总线，是CPU或有DMA能力的单元，用来沟通这些单元想要访问（读取/写入）计算机内存组件/地方的物理地址。它是单向的，只能从CPU传向外部存储器或I/O端口</p>
<p>有个说法：64位系统装了64位操作系统，最大物理内存理论上=2的64次方；然而实际上地址总线只用到了35位，所以最大物理内存是32G大小</p>
<p><strong>控制总线</strong></p>
<p>（1）CPU通过控制总线对外部器件进行控制。</p>
<p>（2）控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<p>（3）控制总线是控制线数量之和。</p>
<p>控制总线，英文名称：ControlBus，简称：CB。控制总线主要用来传送控制信号和时序信号。控制信号中，有的是微处理器送往存储器和输入输出设备接口电路的，如读/写信号，片选信号、中断响应信号等；也有是其它部件反馈给CPU的</p>
<h3 id="3-2、64位和32位系统区别"><a href="#3-2、64位和32位系统区别" class="headerlink" title="3.2、64位和32位系统区别"></a>3.2、64位和32位系统区别</h3><ul>
<li><p>寄存器是CPU内部最基本的存储单元</p>
</li>
<li><p>CPU的主要组成包括了运算器和控制器。运算器是由算术逻辑单元（ALU）、累加器、状态寄存器、通用寄存器组等组成。</p>
</li>
<li><p>CPU位数=CPU中寄存器的位数=CPU能够一次并行处理的数据宽度（位数）=数据总线宽度</p>
</li>
<li><p><strong>CPU的位宽(位数)一般是以 min{ALU位宽、通用寄存器位宽、数据总线位宽}决定的</strong></p>
</li>
<li><p>CPU对外是通过总线(地址、控制、数据)来和外部设备交互的，总线的宽度是8位，同时CPU的寄存器也是8位，那么这个CPU就叫8位CPU</p>
</li>
<li><p>如果总线是32位，寄存器也是32位的，那么这个CPU就是32位CPU</p>
</li>
<li><p>有一种CPU内部的寄存器是32位的，但总线是16位，准32位CPU</p>
</li>
<li><p>所有的64位CPU兼容32位的指令，32位要兼容16位的指令，所以在64位的CPU上是可以识别32位的指令</p>
</li>
<li><p>在64位的CPU构架上运行了64位的软件操作系统，那么这个系统是64位</p>
</li>
<li><p>在64位的CPU构架上，运行了32位的软件操作系统，那么这个系统就是32位</p>
</li>
<li><p>64位的软件不能运行在32位的CPU之上</p>
</li>
</ul>
<h3 id="3-3、寄存器、缓存、内存三者关系"><a href="#3-3、寄存器、缓存、内存三者关系" class="headerlink" title="3.3、寄存器、缓存、内存三者关系"></a>3.3、寄存器、缓存、内存三者关系</h3><ol>
<li><p>寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p>
</li>
<li><p>内存包含的范围非常广，一般分为只读存储器（ROM）、随机存储器（RAM）和高速缓存存储器（cache）。</p>
</li>
<li><p>寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。</p>
</li>
<li><p>Cache ：即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。</p>
</li>
</ol>
<p>总结：大致来说数据是通过内存-Cache-寄存器，Cache缓存则是为了弥补CPU与内存之间运算速度的差异而设置的的部件。</p>
<h2 id="4、内存、地址和指针"><a href="#4、内存、地址和指针" class="headerlink" title="4、内存、地址和指针"></a>4、内存、地址和指针</h2><h3 id="4-1、内存"><a href="#4-1、内存" class="headerlink" title="4.1、内存"></a>4.1、内存</h3><p>内存含义：</p>
<ul>
<li><p>存储器：计算机的组成中，用来存储程序和数据，辅助CPU进行运算处理的重要部分。</p>
</li>
<li><p>内存：内部存贮器，暂存程序/数据——掉电丢失 SRAM、DRAM、DDR、DDR2、DDR3。</p>
</li>
<li><p>外存：外部存储器，长时间保存程序/数据—掉电不丢ROM、ERRROM、FLASH（NAND、NOR）、硬盘、光盘。</p>
</li>
</ul>
<p>内存是沟通CPU与硬盘的桥梁：</p>
<ul>
<li><p>暂存放CPU中的运算数据</p>
</li>
<li><p>暂存与硬盘等外部存储器交换的数据</p>
</li>
</ul>
<h3 id="4-2、物理存储器和存储地址空间"><a href="#4-2、物理存储器和存储地址空间" class="headerlink" title="4.2、物理存储器和存储地址空间"></a>4.2、物理存储器和存储地址空间</h3><p>有关内存的两个概念：物理存储器和存储地址空间。</p>
<p>物理存储器：实际存在的具体存储器芯片。</p>
<ul>
<li><p>主板上装插的内存条</p>
</li>
<li><p>显示卡上的显示RAM芯片</p>
</li>
<li><p>各种适配卡上的RAM芯片和ROM芯片</p>
</li>
</ul>
<p>存储地址空间：对存储器编码的范围。我们在软件上常说的内存是指这一层含义。</p>
<ul>
<li><p>编码：对每个物理存储单元（一个字节）分配一个号码</p>
</li>
<li><p>寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写</p>
</li>
</ul>
<h3 id="4-3、内存地址"><a href="#4-3、内存地址" class="headerlink" title="4.3、内存地址"></a>4.3、内存地址</h3><ul>
<li><p>将内存抽象成一个很大的一维字符数组。</p>
</li>
<li><p>编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关）。</p>
</li>
<li><p>这个内存编号我们称之为内存地址。</p>
</li>
</ul>
<p>内存中的每一个数据都会分配相应的地址：</p>
<ul>
<li><p>char:占一个字节分配一个地址</p>
</li>
<li><p>int: 占四个字节分配四个地址</p>
</li>
<li><p>float、struct、函数、数组等</p>
</li>
</ul>
<h3 id="4-4、指针和指针变量"><a href="#4-4、指针和指针变量" class="headerlink" title="4.4、指针和指针变量"></a>4.4、指针和指针变量</h3><ul>
<li><p>内存区的每一个字节都有一个编号，这就是“地址”。</p>
</li>
<li><p>如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)</p>
</li>
<li><p>指针的实质就是内存“地址”。指针就是地址，地址就是指针。</p>
</li>
<li><p>指针是内存单元的编号，指针变量是存放地址的变量。</p>
</li>
<li><p><strong>通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样</strong></p>
</li>
</ul>
<h2 id="5、存储类型"><a href="#5、存储类型" class="headerlink" title="5、存储类型"></a>5、存储类型</h2><h3 id="5-1、auto"><a href="#5-1、auto" class="headerlink" title="5.1、auto"></a>5.1、auto</h3><ol>
<li>普通局部变量，自动存储，该对象会自动创建和销毁，调用函数时分配内存，函数结束时释放内存。只在{}内有效，存放在堆栈中一般省略auto,  不会被默认初始化，初值不随机</li>
<li>全局变量，<strong>不允许声明为auto变量</strong>， register不适用于全局变量，生命周期由定义到程序运行结束，没有初始化会<strong>自动赋值0或空字符</strong>。全局变量属于整个程序，不同文件中不能有同名的全局变量，通过<strong>extern</strong>在其他文件中引用使用</li>
</ol>
<h3 id="5-2、static"><a href="#5-2、static" class="headerlink" title="5.2、static"></a>5.2、static</h3><ol>
<li>静态局部变量，生命周期由定义到程序运行结束，在编译时赋初值，<strong>只初始化一次，没有初始化会自动赋值0或空字符</strong>。只在当前{}内有效</li>
<li>静态全局变量，生命周期由定义到程序运行结束，在编译时赋初值，只初始化一次，没有初始化会自动赋值0或空字符。从定义到文件结尾起作用，在一个程序中的其他文件中可以定义同名的静态全局变量，因为作用于不冲突。</li>
</ol>
<h3 id="5-3、extern"><a href="#5-3、extern" class="headerlink" title="5.3、extern"></a>5.3、extern</h3><ol>
<li><p>外部变量声明，是指这是一个已在别的地方定义过的对象，这里只是对变量的一次重复引用，不会产生新的变量。</p>
</li>
<li><p>使用extern时，注意不能重复定义，否则编译报错</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//    程序文件一：</span>
    <span class="token keyword">extern</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//编译警告，extern的变量最好不要初始化</span>
<span class="token comment" spellcheck="true">//    程序文件二：</span>
    <span class="token keyword">extern</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//重复定义，应改为extern int a;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果我们希望该外部变量只能在本文件内使用，而不能被其他文件引用可以在外部变量定义时加static声明。防止别人写的模块误用。</p>
</li>
<li><p>在函数外部定义的全局变量，作用域开始于变量定义，结束于程序文件的结束。我们可以extern来声明外部变量来扩展它的作用域。同一个文件内，extern声明之后就可以作用域扩大到声明处到文件结束。比如在一个函数之后定义外部变量a，之后的函数可以使用该变量，但是之前的函数不能使用，加extern可以解决。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">extern</span> <span class="token keyword">int</span> g1<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">extern</span> <span class="token keyword">int</span> g2<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d\n"</span><span class="token punctuation">,</span> g1<span class="token punctuation">,</span>g2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> g1 <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> g2 <span class="token operator">=</span> <span class="token number">88</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<ol start="5">
<li>多个文件时，可以在未定义该外部变量的文件内做extern声明即可以使用。但是需要注意可能执行一个文件时改变了该全局变量的值，影响其他文件的调用。编译时遇到extern，会先在文件内找是否定义了该外部变量。如果未找到则在链接时在其他文件中找。</li>
</ol>
<h3 id="5-4、register"><a href="#5-4、register" class="headerlink" title="5.4、register"></a>5.4、register</h3><ol>
<li><p>寄存器变量，请求编译器将这个变量保存在CPU的寄存器中，从而加快程序的运行.只是建议CPU这样做，非强制,声明变量为register,编译器并不一定会将它处理为寄存器变量</p>
</li>
<li><p>动态和静态变量都是存放在内存中，程序中遇到该值时用控制器发指令将变量的值送到运算器中，需要存数再保存到内存中。如果频繁使用一个变量，比如一个函数体内的多次循环每次都引用该局部变量，我们则可以把局部变量的值放到CPU的寄存器中，叫寄存器变量。不需要多次到内存中存取提高效率。</p>
</li>
<li><p>但是只能局部自动变量和形参可以做寄存器变量。在函数调用时占用一些寄存器，函数结束时释放。不同系统对register要求也不一样，比如对定义register变量个数，数据类型等限制，有的默认为自动变量处理。所以在程序一般也不用。</p>
</li>
<li><p>register是不能取址的。比如 <code>int i</code>；(自动为auto)<code>int *p=&amp;i;</code>是对的， 但<code>register int j; int *p = &amp;j;</code>是错的，因为无法对寄存器的定址。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> TIME 1000000000</span>

<span class="token keyword">int</span> m<span class="token punctuation">,</span> n <span class="token operator">=</span> TIME<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 全局变量 */</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    time_t start<span class="token punctuation">,</span> stop<span class="token punctuation">;</span>
    <span class="token keyword">register</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> TIME<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 寄存器变量 */</span>
    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> TIME<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* 一般变量   */</span>

    <span class="token function">time</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> a<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">time</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"寄存器变量用时: %d 秒\n"</span><span class="token punctuation">,</span> stop <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">time</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> y<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">time</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"一般变量用时: %d 秒\n"</span><span class="token punctuation">,</span> stop <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">time</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">time</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"全局变量用时: %d 秒\n"</span><span class="token punctuation">,</span> stop <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="5-5、volatile"><a href="#5-5、volatile" class="headerlink" title="5.5、volatile"></a>5.5、volatile</h3><pre class="line-numbers language-c"><code class="language-c">    程序在使用变量时<span class="token punctuation">,</span> 特别是连续多次使用变量时<span class="token punctuation">,</span> 一般是载入寄存器<span class="token punctuation">,</span> 直接从寄存器存取<span class="token punctuation">,</span> 之后再还回内存<span class="token punctuation">;</span>但如果此变量在返回内存时<span class="token punctuation">,</span> 假如内存中的值已经改变了<span class="token punctuation">(</span>从外部修改了<span class="token punctuation">)</span>怎么办<span class="token operator">?</span>
为了避免这种情况的发生<span class="token punctuation">,</span> 可以用 <span class="token keyword">volatile</span> 说明此变量<span class="token punctuation">,</span> 以保证变量的每次使用都是直接从内存存取<span class="token punctuation">.</span>
但这样肯定会影响效率<span class="token punctuation">,</span> 幸好它并不常用<span class="token punctuation">.</span>

另外<span class="token punctuation">:</span> 如果 <span class="token keyword">const</span> <span class="token keyword">volatile</span> 同时使用<span class="token punctuation">,</span> 这表示此变量只接受外部的修改<span class="token punctuation">.</span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">volatile</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>    
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-6、总结"><a href="#5-6、总结" class="headerlink" title="5.6、总结"></a>5.6、总结</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>类型</th>
<th>生命周期</th>
<th>作用域</th>
<th>修饰对象</th>
<th>所属区</th>
</tr>
</thead>
<tbody><tr>
<td>auto[可省略]</td>
<td>普通局部变量</td>
<td>定义到{}运行结束</td>
<td>｛｝</td>
<td>变量</td>
<td>栈区</td>
</tr>
<tr>
<td>static</td>
<td>静态局部变量</td>
<td>定义到程序运行结束</td>
<td>｛｝</td>
<td>变量和函数</td>
<td>初始化在data段，未初始化在BSS段</td>
</tr>
<tr>
<td></td>
<td>全局变量</td>
<td>定义到程序运行结束</td>
<td>定义到文件结尾</td>
<td></td>
<td>初始化在data段，未初始化在BSS段</td>
</tr>
<tr>
<td>extern</td>
<td>全局变量</td>
<td>定义到程序运行结束</td>
<td>声明处到文件结尾</td>
<td>变量和函数</td>
<td>初始化在data段，未初始化在BSS段</td>
</tr>
<tr>
<td>static</td>
<td>全局变量</td>
<td>整个程序运行期</td>
<td>声明处到文件结尾</td>
<td>变量和函数</td>
<td>初始化在data段，未初始化在BSS段</td>
</tr>
<tr>
<td>register</td>
<td>寄存器变量</td>
<td>定义到{}运行结束</td>
<td>｛｝</td>
<td>变量</td>
<td>运行时存储在CPU寄存器</td>
</tr>
<tr>
<td>extern</td>
<td>函数</td>
<td>整个程序运行期</td>
<td>声明处到文件结尾</td>
<td></td>
<td>代码区</td>
</tr>
<tr>
<td>static</td>
<td>函数</td>
<td>整个程序运行期</td>
<td>声明处到文件结尾</td>
<td></td>
<td>代码区</td>
</tr>
</tbody></table>
<h2 id="6、内存分区"><a href="#6、内存分区" class="headerlink" title="6、内存分区"></a>6、内存分区</h2><p>C代码经过预处理、编译、汇编、链接4步后生成一个可执行程序。在 Linux 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：</p>
<p><img src="01.png" alt></p>
<p>通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分（有些人直接把data和bss合起来叫做静态区或全局区）。</p>
<ul>
<li><p><strong>代码区</strong></p>
<p>存放 CPU 执行的机器指令。通常代码区是<strong>可共享</strong>的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是<strong>只读的</strong>，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。</p>
</li>
<li><p><strong>全局初始化数据区/静态数据区（data段）</strong></p>
<p>该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</p>
</li>
<li><p><strong>未初始化数据区（又叫 bss 区）</strong></p>
<p>存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。</p>
</li>
</ul>
<p>程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。</p>
<p><img src="02.png" alt></p>
<ul>
<li><p>代码区（text segment）</p>
<p>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。</p>
</li>
<li><p>只读数据区（文字常量区 RO data）</p>
<p>只读数区是程序使用的一些不会被更改的数据。一般是const修饰的变量以及程序中使用的文字常量。</p>
</li>
<li><p>已初始化数据区 （RW data）</p>
<p>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据）的数据的生存周期为整个程序运行过程。</p>
</li>
<li><p>未初始化数据区（BSS）</p>
<p>加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</p>
</li>
<li><p>堆区（heap）</p>
<p>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p>
</li>
<li><p>栈区（stack）</p>
<p>栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。</p>
</li>
</ul>
<h2 id="7、结构体字节对齐"><a href="#7、结构体字节对齐" class="headerlink" title="7、结构体字节对齐"></a>7、结构体字节对齐</h2><p><strong>7.1、内存对齐原因</strong></p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> data
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> c<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5还是 8?</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Linux 32位架构下，假设变量stu存放在内存中的起始地址为0x00，那么c的起始地址为0x00、i的起始地址为0x01，变量stu共占用了5个字节：</p>
<ul>
<li><p>对变量c访问：CPU只需要一个读周期</p>
</li>
<li><p>变量i访问：</p>
</li>
</ul>
<ol>
<li><p>首先CPU用一个读周期，从0x00处读取了4个字节(32位架构)，然后将0x01-0x03的3个字节暂存。</p>
</li>
<li><p>再花一个读周期读取了从0x04-0x07的4字节数据，将0x04这个字节与刚刚暂存的3个字节进行拼接从而读取到成员变量i的值。</p>
</li>
<li><p>读取一个成员变量i，CPU却花费了2个读周期。</p>
</li>
</ol>
<p>如果数据成员i的起始地址被放在了0x04处</p>
<ul>
<li><p>读取c成员，花费周期为1  </p>
</li>
<li><p>读取i所花费的周期也变成了1</p>
</li>
<li><p>引入字节对齐可以避免读取效率的下降，同时也浪费了3个字节的空间(0x01-0x03)</p>
<p><strong>结构体内部成员对齐是为了实现用空间换取时间。</strong></p>
</li>
</ul>
<p><strong>7.2、内存对齐原则</strong></p>
<ul>
<li><p>原则1：数据成员的对齐规则</p>
<p>1) 最大对齐单位以CPU架构对齐，如Linux 32位最大以4字节对齐，Linux 64位最大以8字节对齐，vs(32位、64位)最大对齐单位为8字节</p>
<p>2) 需要和<strong>结构体的最大成员</strong>和CPU架构(32位或64位)对比，取小的作为对齐单位</p>
<p>3) 字节对齐也可以通过程序控制，采用指令：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">pragma</span> pack(xx)   </span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> pack(1)     </span><span class="token comment" spellcheck="true">//1字节对齐</span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> pack(2)     </span><span class="token comment" spellcheck="true">//2字节对齐</span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> pack(4)     </span><span class="token comment" spellcheck="true">//4字节对齐</span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> pack(8)     </span><span class="token comment" spellcheck="true">//8字节对齐</span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> pack(16)    </span><span class="token comment" spellcheck="true">//16字节对齐</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>  #include &lt;stdio.h&gt;</p>
<p>  #include &lt;stdlib.h&gt;</p>
<p>  #pragma pack(2)</p>
<p>  typedef struct<br>  {<br>    int aa1; //4个字节对齐 1111<br>    char bb1;//1个字节对齐 1<br>    short cc1;//2个字节对齐 011<br>    char dd1; //1个字节对齐 1<br>    } testlength;</p>
<p>  int length = sizeof(testlength); //2个字节对齐，length = 10</p>
<p>  int main(){<br>      printf(“length=%d\n”, length); // length=10<br>  }</p>
<pre><code>
  尽管通过pragma pack(xx)可以指定字节对齐单位，但需要和结构体的最大成员、CPU架构(32位或64位)对比，取最小的作为对齐单位。

- 原则2：数据成员的偏移起点

  结构体（struct）的数据成员，第一个数据成员放在偏移量为0的地方，以后每个数据成员存放在偏移量为该数据成员类型大小的整数倍的地方（比如int在32位机器为４字节，则要从4的整数倍地址开始存储）

- 原则3：收尾工作 

  结构体的总大小，也就是sizeof的结果，必须是对齐单位的整数倍，不足的要补齐。



## 8、typedef与define的区别

- typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型。

- 与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值

- define发生在预处理，typedef发生在编译阶段



## 9、C语言文本操作的区别

### 9.1 二进制文件和文本文件



- b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的

- Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾

- 在Windows平台下，以“文本”方式打开文件，不加b：

  - 当读取文件的时候，系统会将所有的 &quot;\r\n&quot; 转换成 &quot;\n&quot;

  - 当写入文件的时候，系统会将 &quot;\n&quot; 转换成 &quot;\r\n&quot; 写入 

  - 以&quot;二进制&quot;方式打开文件，则读\写都不会进行这样的转换

- 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，&quot;\r\n&quot; 作为两个字符原样输入输出

### 9.2 文本结尾

在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。

`#define EOF (-1)`

当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。

```c
#include &lt;stdio.h&gt;
int feof(FILE * stream);
功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。
参数：
    stream：文件指针
返回值：
    非0值：已经到文件结尾
    0：没有到文件结尾</code></pre><h2 id="10、void"><a href="#10、void" class="headerlink" title="10、void"></a>10、void</h2><p><strong>void的作用</strong></p>
<ul>
<li>对函数参数的限定：当不需要传入参数时，即 <code>function (void);</code></li>
<li>对函数返回值的限定：当函数没有返回值时，即 <code>void function(void);</code></li>
</ul>
<p><strong>void指针的作用</strong></p>
<p>（1）void指针可以指向任意的数据类型，即任意类型的指针可以赋值给void指针</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
p<span class="token operator">=</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果void指针赋值给其他类型，则需要强制转换；<code>a=（int *）p;</code></p>
<p>（2）在ANSI C标准中不允许对void指针进行算术运算，因为没有特定的数据类型，即在内存中不知道移动多少个字节；而在GNU标准中，认为void指针和char指针等同。</p>
<p><strong>应用</strong></p>
<p>（1）void指针一般用于应用的底层，比如malloc函数的返回类型是void指针，需要再强制转换； </p>
<p>（2）文件句柄HANDLE也是void指针类型，这也是句柄和指针的区别； </p>
<p>（3）内存操作函数的原型也需要void指针限定传入参数：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memcpy</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memset</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> size_t num <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>（4）面向对象函数中底层对基类的抽象。</p>
<h2 id="11、数据类型的本质"><a href="#11、数据类型的本质" class="headerlink" title="11、数据类型的本质"></a>11、数据类型的本质</h2><ul>
<li><p>数据类型可理解为创建变量的模具：是固定内存大小的别名。</p>
</li>
<li><p>数据类型的作用：编译器预算对象（变量）分配的内存空间大小。</p>
</li>
</ul>
<h2 id="12、变量的本质"><a href="#12、变量的本质" class="headerlink" title="12、变量的本质"></a>12、变量的本质</h2><p>变量的本质：一段连续内存空间的别名。</p>
<pre><code>1）程序通过变量来申请和命名内存空间 int a = 0

2）通过变量名访问内存空间

3）不是向变量读写数据，而是向变量所代表的内存空间中读写数据</code></pre><h2 id="13、数组与指针的关系"><a href="#13、数组与指针的关系" class="headerlink" title="13、数组与指针的关系"></a>13、数组与指针的关系</h2><p>数组不是指针，数组名也只有在表达式中才会被当成一个指针常量。数组名在表达式中使用的时候，编译器才会产生一个指针常量。</p>
<ul>
<li><p><code>p[i]</code>这种写法只不过是<code>*(p + i)</code>的简便写法。实际上，至少对于编译器来说，[]这样的运算符完全可以不存在。[]运算符是为了方便人们读写而引入的，是一种语法糖。</p>
</li>
<li><p>当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。</p>
</li>
<li><p>当数组名作为 &amp; 操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。</p>
</li>
<li><p>二级指针是指向指针的指针，而指针数组则是元素类型为指针的数组。虽然它们是不一样的，但是在表达式中，它们是等效的。</p>
</li>
</ul>
<h2 id="14、字节序-大端、小端"><a href="#14、字节序-大端、小端" class="headerlink" title="14、字节序(大端、小端)"></a>14、字节序(大端、小端)</h2><p><strong>14.1 大端和小端</strong></p>
<p>计算机的内存最小单位是字节。字节序是指多字节(大于1字节)数据的存储顺序，在设计计算机系统的时候，有两种处理内存中数据的方法：大端格式、小端格式。</p>
<ul>
<li><p>小端格式(Little-Endian)：将低位字节数据存储在低地址。X86和ARM都是小端对齐。</p>
</li>
<li><p>大端格式(Big-Endian)：将高位字节数据存储在低地址。很多Unix服务器的CPU是大端对齐的、网络上数据是以大端对齐。</p>
</li>
</ul>
<p><img src="03.png" alt></p>
<p>对于整形 0x12345678，它在大端格式和小端格式的系统中，分别如下图所示的方式存放：</p>
<p><img src="04.png" alt></p>
<p><strong>14.2 网络字节序和主机字节序</strong></p>
<p>网络字节顺序NBO(Network Byte Order)</p>
<pre><code>在网络上使用统一的大端模式，低字节存储在高地址，高字节存储在低地址。</code></pre><p>主机字节序顺序HBO(Host Byte Order)</p>
<pre><code>不同的机器HBO不相同，与CPU设计相关，数据的顺序是由CPU决定的，而与操作系统无关。</code></pre><p>处理器 |操作系统  |字节排序|</p>
<p>Alpha    全部    Little endian<br>HP-PA    NT    Little endian<br>HP-PA    UNIX    Big endian<br>Intelx86    全部    Little endian &lt;—–x86系统是小端字节序系统<br>Motorola680x()    全部    Big endian<br>MIPS    NT    Little endian<br>MIPS    UNIX    Big endian<br>PowerPC    NT    Little endian<br>PowerPC    非NT    Big endian  &lt;—–PPC系统是大端字节序系统<br>RS/6000    UNIX    Big endian<br>SPARC    UNIX    Big endian<br>IXP1200 ARM核心    全部    Little endian </p>
<pre class="line-numbers language-c"><code class="language-c">相关函数：
htons 把<span class="token keyword">unsigned</span> <span class="token keyword">short</span>类型从主机序转换到网络序
htonl 把<span class="token keyword">unsigned</span> <span class="token keyword">long</span>类型从主机序转换到网络序
ntohs 把<span class="token keyword">unsigned</span> <span class="token keyword">short</span>类型从网络序转换到主机序
ntohl 把<span class="token keyword">unsigned</span> <span class="token keyword">long</span>类型从网络序转换到主机序

头文件：#include <span class="token operator">&lt;</span>netinet<span class="token operator">/</span>in<span class="token punctuation">.</span>h<span class="token operator">></span>
定义函数：<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> netshort<span class="token punctuation">)</span><span class="token punctuation">;</span>
函数说明：<span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>用来将参数指定的<span class="token number">16</span> 位netshort 转换成主机字符顺序<span class="token punctuation">.</span>
返回值：返回对应的主机顺序<span class="token punctuation">.</span>
范例：参考<span class="token function">getservent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;winsock.h></span> </span><span class="token comment" spellcheck="true">// windows使用winsock.h</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//左边是高位，右边是低位，高位放高地址，低位放低地址</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x11223344</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    u_long b <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x\n"</span><span class="token punctuation">,</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//  gcc hello.c -lwsock32 -o hello</span>
<span class="token comment" spellcheck="true">// 编译时添加-lwsock32，不然会报错undefined reference to `htonl@4'</span>
<span class="token comment" spellcheck="true">// 在编译socket程序的时候，一定要加上-l wsock32选项，因为mingw默认没有包含windows库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="15、数组指针"><a href="#15、数组指针" class="headerlink" title="15、数组指针"></a>15、数组指针</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 1) 先定义数组类型，再根据类型定义指针变量</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 2) 先定义数组指针类型，根据类型定义指针变量</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>P<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//第一个()代表指针，第二个[]代表数组</span>
P q<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数据组指针变量</span>

<span class="token comment" spellcheck="true">// 3) 直接定义数组指针变量</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="16、深拷贝和浅拷贝"><a href="#16、深拷贝和浅拷贝" class="headerlink" title="16、深拷贝和浅拷贝"></a>16、深拷贝和浅拷贝</h2><p><strong>结构体</strong>:</p>
<p>浅拷贝  不同结构体成员指针变量指向同一块内存</p>
<p>深拷贝  不同结构体成员指针变量指向不同的内存</p>
<p><strong>类</strong>:</p>
<p>浅拷贝 类中有动态分配的空间的指针指向相同</p>
<p>深拷贝 类中有动态分配的空间的指针指向不同的内存空间</p>
<h2 id="17、-include-lt-gt-与-include-“”的区别"><a href="#17、-include-lt-gt-与-include-“”的区别" class="headerlink" title="17、#include&lt; &gt; 与 #include “”的区别"></a>17、#include&lt; &gt; 与 #include “”的区别</h2><ul>
<li><p>“” 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索。</p>
</li>
<li><p>&lt; &gt; 表示系统直接按系统指定的目录检索。</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>#include &lt;&gt;常用于包含库函数的头文件</li>
<li>#include “”常用于包含自定义的头文件</li>
<li>理论上#include可以包含任意格式的文件(.c .h等) ，但我们一般用于头文件的包含。</li>
</ul>
<h2 id="18、静态库和动态库"><a href="#18、静态库和动态库" class="headerlink" title="18、静态库和动态库"></a>18、静态库和动态库</h2><p><strong>18.1、静态库优缺点</strong></p>
<ul>
<li><p>静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；</p>
</li>
<li><p>程序在运行时与函数库再无瓜葛，移植方便；</p>
</li>
<li><p>浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</p>
</li>
</ul>
<p><strong>18.2、动态库</strong></p>
<p>要解决空间浪费和更新困难这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们静态的链接在一起。</p>
<p>简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。</p>
<p><strong>18.3、动态库的lib文件和静态库的lib文件的区别</strong></p>
<p>在使用动态库的时候，往往提供两个文件：一个引入库（.lib）文件（也称“导入库文件”）和一个DLL（.dll）文件。 </p>
<p>虽然引入库的后缀名也是“lib”，但是，动态库的引入库文件和静态库文件有着本质的区别，对一个DLL文件来说，其引入库文件（.lib）包含该DLL导出的函数和变量的符号名，而.dll文件包含该DLL实际的函数和数据。</p>
<p>在使用动态库的情况下，在编译链接可执行文件时，只需要链接该DLL的引入库文件，该DLL中的函数代码和数据并不复制到可执行文件，直到可执行程序运行时，才去加载所需的DLL，将该DLL映射到进程的地址空间中，然后访问DLL中导出的函数。</p>
<h1 id="二、C-篇"><a href="#二、C-篇" class="headerlink" title="二、C++篇"></a>二、C++篇</h1><h2 id="1、c语言和c-语言的关系"><a href="#1、c语言和c-语言的关系" class="headerlink" title="1、c语言和c++语言的关系"></a>1、c语言和c++语言的关系</h2><p>“c++”中的++来自于c语言中的递增运算符++，该运算符将变量加1。c++起初也叫”c with clsss”。通过名称表明，c++是对C的扩展，因此c++是c语言的超集，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。</p>
<p>c++语言在c语言的基础上添加了<strong>面向对象编程</strong>和<strong>泛型编程</strong>的支持。c++继承了c语言高效，简洁，快速和可移植的传统。</p>
<p>c++融合了3种不同的编程方式:</p>
<ul>
<li><p>c语言代表的过程性语言.</p>
</li>
<li><p>c++在c语言基础上添加的类代表的面向对象语言.</p>
</li>
<li><p>c++模板支持的泛型编程。</p>
</li>
</ul>
<h2 id="2、左值和右值"><a href="#2、左值和右值" class="headerlink" title="2、左值和右值"></a>2、左值和右值</h2><p>判断是否是左值，有一个简单的方法，就是看看能否取它的地址，能取地址就是左值，否则就是右值。</p>
<p>当一个对象成为右值时，使用的是它的值(内容), 而成为左值时，使用的是它的身份（在内存中的位置）。</p>
<p>平常所说的引用，实际上指的就是左值引用<code>lvalue reference</code>, 常用单个&amp;来表示。左值引用只能接收左值，不能接收右值。<strong>const关键字会让左值引用变得不同，它可以接收右值。</strong></p>
<p><strong>为了支持移动操作，在c++11版本，增加了右值引用。</strong>右值引用一般用于绑定到一个即将销毁的对象，所以右值引用又通常出现在移动构造函数中。</p>
<p>看完下面的例子，左值和右值基本就清楚了，左值具有持久的状态，有独立的内存空间，右值要么是字面常量，要么就是表达式求值过程中创建的临时对象</p>
<pre class="line-numbers language-c++"><code class="language-c++">int i = 66;
int &r = i ; //r 是一个左引用，绑定左值 i

int &&rr = i ; //rr是一个右引用，绑定到左值i , 错误！
int &r2 = i*42 ; //  r2 是一个左引用， 而i*42是一个表达式，计算出来的结果是一个右值。 错误！

const int &r3 = i*42; // const修饰的左值引用 正确
int &&rr2 = i*42 ; // 右引用，绑定右值 正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="3、c-对c的扩展"><a href="#3、c-对c的扩展" class="headerlink" title="3、c++对c的扩展"></a>3、c++对c的扩展</h2><p><strong>3.1 三目运算符</strong></p>
<p>c语言三目运算表达式返回值为数据值，为右值，不能赋值。</p>
<p>c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。</p>
<pre class="line-numbers language-c++"><code class="language-c++">int a = 10;
int b = 20;
printf("ret:%d\n", a > b ? a : b);
//思考一个问题，(a > b ? a : b) 三目运算表达式返回的是什么？

cout << "b:" << b << endl;
//返回的是左值，变量的引用
(a > b ? a : b) = 100;//返回的是左值，变量的引用
cout << "b:" << b << endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3.2 bool</strong></p>
<p>c++中新增bool类型关键字</p>
<ul>
<li>bool类型只有两个值，true(1)， false（0）</li>
<li>bool类型占1个字节</li>
<li>给bool类型赋值时, 非0值会自动转换为true(1), 0值会自动转换为false（0）</li>
</ul>
<p>C语言中也有bool类型，在c99标准之前是没有bool关键字，c99标准已经有bool类型，包含头文件<code>stdbool.h</code>,就可以使用和c++一样的bool类型。</p>
<p><strong>3.3 struct类型增强</strong></p>
<ul>
<li><p>c中定义结构体变量需要加上struct关键字，c++不需要。</p>
</li>
<li><p>c中的结构体只能定义成员变量，不能定义成员函数。c++即可以定义成员变量，也可以定义成员函数。</p>
</li>
</ul>
<p><strong>3.4 更严格的类型转换</strong></p>
<p>在C++中，不同类型的变量一般是不能直接赋值的，需要相应的强转。</p>
<p>在C++中，所有的变量和函数都必须有类型</p>
<p><strong>3.4 全局变量检测增强</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">int a = 10; //赋值，当做定义
int a; //没有赋值，当做声明

int main(){
    printf("a:%d\n",a);
    return EXIT_SUCCESS;
}

// 上面的代码在c++下编译失败，在c下编译通过。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="4、内部连接和外部连接"><a href="#4、内部连接和外部连接" class="headerlink" title="4、内部连接和外部连接"></a>4、内部连接和外部连接</h2><p>内部连接：如果一个名称对编译单元(.cpp)来说是局部的，在链接的时候其他的编译单元无法链接到它且不会与其它编译单元(.cpp)中的同样的名称相冲突。例如static函数，inline函数等（注 : 用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。）</p>
<p>外部连接：如果一个名称对编译单元(.cpp)来说不是局部的，而在链接的时候其他的编译单元可以访问它，也就是说它可以和别的编译单元交互。 例如全局变量就是外部链接 。</p>
<h2 id="5、C-C-中const的区别"><a href="#5、C-C-中const的区别" class="headerlink" title="5、C/C++中const的区别"></a>5、C/C++中const的区别</h2><p>1、const全局变量</p>
<p>c语言全局const会被存储到只读数据区。c++中全局const当声明extern或者对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。两个都受到了只读数据区的保护，不可修改。</p>
<pre class="line-numbers language-c++"><code class="language-c++">const int constA = 10;
int main(){
    int* p = (int*)&constA;
    *p = 200;
}

// 以上代码在c/c++中编译通过，在运行期，修改constA的值时，发生写入错误。原因是修改只读数据段的数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2、const 局部变量</p>
<p>c语言中局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。</p>
<pre class="line-numbers language-c++"><code class="language-c++">const int constA = 10;
int* p = (int*)&constA;
*p = 300;
printf("constA:%d\n",constA);
printf("*p:%d\n", *p);

// constA:300
// *p:300<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>c++中对于局部的const变量要区别对待：</p>
<ul>
<li>对于基础数据类型，也就是const int a = 10这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配内存。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">const int constA = 10;
int* p = (int*)&constA;
*p = 300;
cout << "constA:" << constA << endl;
cout << "*p:" << *p << endl;

// constA:10
// *p:300
// constA在符号表中，当我们对constA取地址，这个时候为constA分配了新的空间，*p操作的是分配的空间，而constA是从符号表获得的值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    </p>
<ul>
<li>对于基础数据类型，如果用一个变量初始化const变量，如果const int a = b,那么也是会给a分配内存。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int b = 10;
const int constA = b;
int* p = (int*)&constA;
*p = 300;
cout << "constA:" << constA << endl;
cout << "*p:" << *p << endl;

// constA:300
// *p:300 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>对于自定数据类型，比如类对象，那么也会分配内存。</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">const Person person; //未初始化age
//person.age = 50; //不可修改
Person* pPerson = (Person*)&person;
//指针间接修改
pPerson->age = 100;
cout << "pPerson->age:" << pPerson->age << endl;
pPerson->age = 200;
cout << "pPerson->age:" << pPerson->age << endl;

// pPerson->age:100
// pPerson->age:200
//为person分配了内存，所以我们可以通过指针的间接赋值修改person对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3、链接方式</p>
<p>c中const默认为外部连接，c++中const默认为内部连接.当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在c++中，则不会，因为c++中的const默认是内部连接的。如果想让c++中的const具有外部连接，必须显示声明为: extern const int a = 10;</p>
<h2 id="6、const与-define的区别"><a href="#6、const与-define的区别" class="headerlink" title="6、const与#define的区别"></a>6、const与#define的区别</h2><ul>
<li><p>const有数据类型，可进行编译器类型安全检查。#define无类型，不可以进行类型检查</p>
</li>
<li><p>const有作用域，而#define不重视作用域，默认定义处到文件结尾。如果想定义在指定作用域下有效的常量，那么#define就不能用。</p>
</li>
</ul>
<h2 id="7、引用"><a href="#7、引用" class="headerlink" title="7、引用"></a>7、引用</h2><ol>
<li><p>&amp;在此不是求地址运算，而是起标识作用。</p>
</li>
<li><p>类型标识符是指目标变量的类型</p>
</li>
<li><p>必须在声明引用变量时进行初始化。</p>
</li>
<li><p>引用初始化之后不能改变。</p>
</li>
<li><p>不能有NULL引用。必须确保引用是和一块合法的存储单元关联。</p>
</li>
<li><p><strong>可以建立对数组的引用。</strong></p>
</li>
<li><p>函数不能返回局部变量的引用</p>
</li>
<li><p>函数当左值，必须返回引用</p>
</li>
</ol>
<p><strong>引用的本质</strong></p>
<p>引用的本质是在c++内部实现一个指针常量</p>
<p><code>Type&amp; ref = val;  // Type* const ref = val;</code></p>
<p>c++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。</p>
<pre class="line-numbers language-c++"><code class="language-c++">//发现是引用，转换为 int* const ref = &a;
void testFunc(int& ref){
    ref = 100; // ref是引用，转换为*ref = 100
}
int main(){
    int a = 10;
    int& aRef = a; //自动转换为 int* const aRef = &a;这也能说明引用为什么必须初始化
    aRef = 20; //内部发现aRef是引用，自动帮我们转换为: *aRef = 20;
    cout << "a:" << a << endl;
    cout << "aRef:" << aRef << endl;
    testFunc(a);
    return EXIT_SUCCESS;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="8、面向对象的三大特性"><a href="#8、面向对象的三大特性" class="headerlink" title="8、面向对象的三大特性"></a>8、面向对象的三大特性</h2><p><strong>封装</strong></p>
<ol>
<li>把变量（属性）和函数（操作）合成一个整体，封装在一个类中</li>
<li>对变量和函数进行访问控制</li>
</ol>
<p><strong>继承</strong></p>
<pre><code>c++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。

派生类继承基类，派生类拥有基类中全部成员变量和成员方法（除了构造和析构之外的成员方法），但是在派生类中，继承的成员并不一定能直接访问，不同的继承方式会导致不同的访问权限。

任何时候重新定义基类中的一个重载函数，在新类中所有的其他版本将被自动隐藏.

operator=也不能被继承，因为它完成类似构造函数的行为。</code></pre><p><strong>多态</strong></p>
<pre><code>c++支持编译时多态(静态多态)和运行时多态(动态多态)，运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。

静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定(动态多态,运行时多态)。

多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性。</code></pre><h2 id="9、C-编译器优化技术：RVO-NRVO和复制省略"><a href="#9、C-编译器优化技术：RVO-NRVO和复制省略" class="headerlink" title="9、C++编译器优化技术：RVO/NRVO和复制省略"></a>9、C++编译器优化技术：RVO/NRVO和复制省略</h2><p>现代编译器缺省会使用RVO（return value optimization，返回值优化）、NRVO（named return value optimization、命名返回值优化）和复制省略（Copy elision）技术，来减少拷贝次数来提升代码的运行效率</p>
<p>注1：vc6、vs没有提供编译选项来关闭该优化，无论是debug还是release都会进行RVO和复制省略优化</p>
<p>注2：vc6、vs2005以下及vs2005+ Debug上不支持NRVO优化，vs2005+ Release支持NRVO优化</p>
<p>注3：g++支持这三种优化，并且可通过编译选项：-fno-elide-constructors来关闭优化</p>
<p><strong>RVO</strong></p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <stdio.h>
class A
{
public:
    A()
    {
        printf("%p construct\n", this);
    }
    A(const A& cp)
    {
        printf("%p copy construct\n", this);
    }
    ~A() 
    {
        printf("%p destruct\n", this);
    }
};

A GetA()
{
    return A();
}

int main()
{
    {
        A a = GetA();
    }

    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在g++和vc6、vs中，上述代码仅仅只会调用一次构造函数和析构函数 ，输出结果如下：</p>
<pre><code>0x7ffe9d1edd0f construct
0x7ffe9d1edd0f destruct</code></pre><p>在g++中，加上-fno-elide-constructors选项关闭优化后，输出结果如下：</p>
<pre><code>0x7ffc46947d4f construct  // 在函数GetA中，调用无参构造函数A()构造出一个临时变量temp
0x7ffc46947d7f copy construct // 函数GetA return语句处，把临时变量temp做为参数传入并调用拷贝构造函数A(const A&amp; cp)将返回值ret构造出来
0x7ffc46947d4f destruct // 函数GetA执行完return语句后，临时变量temp生命周期结束，调用其析构函数~A()
0x7ffc46947d7e copy construct // 函数GetA调用结束，返回上层main函数后，把返回值变量ret做为参数传入并调用拷贝构造函数A(const A&amp; cp)将变量A a构造出来
0x7ffc46947d7f destruct // A a = GetA()语句结束后，返回值ret生命周期结束，调用其析构函数~A()
0x7ffc46947d7e destruct // A a要离开作用域，生命周期结束，调用其析构函数~A()</code></pre><p>注：临时变量temp、返回值ret均为匿名变量</p>
<p><strong>NRVO</strong></p>
<p>g++编译器、vs2005+ Release（开启/O2及以上优化开关）</p>
<p>修改上述代码，将GetA的实现修改成：</p>
<pre class="line-numbers language-c++"><code class="language-c++">A GetA()
{
    A o;
    return o;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在g++、vs2005+ Release中，上述代码也仅仅只会调用一次构造函数和析构函数 ，输出结果如下：</p>
<pre><code>0x7ffe9d1edd0f construct
0x7ffe9d1edd0f destruct</code></pre><p>g++加上-fno-elide-constructors选项关闭优化后，和上述结果一样</p>
<pre><code>0x7ffc46947d4f construct
0x7ffc46947d7f copy construct
0x7ffc46947d4f destruct
0x7ffc46947d7e copy construct
0x7ffc46947d7f destruct
0x7ffc46947d7e destruct</code></pre><p>但在vc6、vs2005以下、vs2005+ Debug中，没有进行NRVO优化，输出结果为：</p>
<pre><code>18fec4 construct  // 在函数GetA中，调用无参构造函数A()构造出一个临时变量o
18ff44 copy construct  // 函数GetA return语句处，把临时变量o做为参数传入并调用拷贝构造函数A(const A&amp; cp)将返回值ret构造出来
18fec4 destruct  // 函数GetA执行完return语句后，临时变量o生命周期结束，调用其析构函数~A()
18ff44 destruct // A a要离开作用域，生命周期结束，调用其析构函数~A()</code></pre><p>注：<strong>与g++、vs2005+ Release相比，vc6、vs2005以下、vs2005+ Debug只优化掉了返回值到变量a的拷贝，命名局部变量o没有被优化掉，所以最后一共有2次构造和析构的调用</strong></p>
<p><strong>复制省略</strong></p>
<p>典型情况是：调用构造函数进行值类型传参</p>
<pre><code>void Func(A a) 
{
}

int main()
{
    {
        Func(A());
    }

    return 0;
}</code></pre><p>在g++和vc6、vs中，上述代码仅仅只会调用一次构造函数和析构函数 ，输出结果如下：</p>
<pre><code>0x7ffeb5148d0f construct
0x7ffeb5148d0f destruct</code></pre><p>在g++中，加上-fno-elide-constructors选项关闭优化后，输出结果如下： </p>
<pre><code>0x7ffc53c141ef construct   // 在main函数中，调用无参构造函数构造实参变量o
0x7ffc53c141ee copy construct // 调用Func函数后，将实参变量o做为参数传入并调用拷贝构造函数A(const A&amp; cp)将形参变量a构造出来
0x7ffc53c141ee destruct // 函数Func执行完后，形参变量a生命周期结束，调用其析构函数~A()
0x7ffc53c141ef destruct // 返回main函数后，实参变量o要离开作用域，生命周期结束，调用其析构函数~A()</code></pre><p><strong>优化失效的情况</strong></p>
<ol>
<li>根据不同的条件分支，返回不同变量</li>
<li>返回参数变量</li>
<li>返回全局变量</li>
<li>返回复合函数类型中的成员变量</li>
<li>返回值赋值给已构造好的变量（此时会调用operator==赋值运算符）</li>
</ol>
<p><a href="https://www.cnblogs.com/kekec/p/11303391.html" target="_blank" rel="noopener">https://www.cnblogs.com/kekec/p/11303391.html</a></p>
<h2 id="10、explicit关键字"><a href="#10、explicit关键字" class="headerlink" title="10、explicit关键字"></a>10、explicit关键字</h2><ul>
<li><p>explicit用于修饰构造函数,防止隐式转化。</p>
</li>
<li><p>是针对单参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。</p>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">class MyString{
public:
    explicit MyString(int n){
        cout << "MyString(int n)!" << endl;
    }
    MyString(const char* str){
        cout << "MyString(const char* str)" << endl;
    }
};

int main(){

    //给字符串赋值？还是初始化？
    //MyString str1 = 1; 
    MyString str2(10);

    //寓意非常明确，给字符串赋值
    MyString str3 = "abcd";
    MyString str4("abcd");

    return EXIT_SUCCESS;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="11、new-delete-malloc-free"><a href="#11、new-delete-malloc-free" class="headerlink" title="11、new/delete/malloc/free"></a>11、new/delete/malloc/free</h2><p><strong>11.1、new</strong></p>
<ol>
<li>内存申请成功后，会返回一个指向该内存的地址。</li>
<li>若内存申请失败，则抛出异常，</li>
<li>申请成功后，如果是程序员定义的类型，会执行相应的构造函数</li>
</ol>
<p><strong>11.2、delete</strong></p>
<ol>
<li>如果指针的值是0 ，delete不会执行任何操作，有检测机制</li>
<li>delete只是释放内存，不会修改指针，指针仍然会指向原来的地址</li>
<li>重复delete，有可能出现异常</li>
<li>如果是自定义类型，会执行析构函数</li>
</ol>
<p><strong>11.3、malloc</strong></p>
<ol>
<li>malloc 申请成功之后，返回的是void类型的指针。需要将void*指针转换成我们需要的类型。1.</li>
<li>malloc 要求制定申请的内存大小 ， 而new由编译器自行计算。</li>
<li>申请失败，返回的是NULL ， 比如： 内存不足。</li>
<li>不会执行自定义类型的构造函数</li>
</ol>
<p><strong>11.4、free</strong></p>
<ol>
<li>如果是空指针，多次释放没有问题，非空指针，重复释放有问题</li>
<li>不会执行对应的析构</li>
<li>delete的底层执行的是free</li>
</ol>
<h2 id="12、const"><a href="#12、const" class="headerlink" title="12、const"></a>12、const</h2><ol>
<li>const修饰静态成员变量时可以在类内部初始化</li>
<li>const 修饰成员函数时，修饰的是this指针，所以成员函数内不可以修改任何普通成员变量，当成员变量类型符前用mutable修饰时例外</li>
<li>常对象(cons修饰的对象)只能调用const修饰的成员函数</li>
<li>常对象可以访问成员属性，但是不能修改</li>
<li><strong>const关键字会让左值引用变得不同，它可以接收右值。</strong></li>
</ol>
<h2 id="13、虚继承"><a href="#13、虚继承" class="headerlink" title="13、虚继承"></a>13、虚继承</h2><p>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，多重继承可能存在一个基类的多份拷贝，这就出现了二义性。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class BigBase{
public:
    BigBase(){ mParam = 0; }
    void func(){ cout << "BigBase::func" << endl; }
public:
    int mParam;
};

class Base1 : public BigBase{};
class Base2 : public BigBase{};
class Derived : public Base1, public Base2{};

int main(){

    Derived derived;
    //1. 对“func”的访问不明确
    //derived.func();
    //cout << derived.mParam << endl;
    cout << "derived.Base1::mParam:" << derived.Base1::mParam << endl;
    cout << "derived.Base2::mParam:" << derived.Base2::mParam << endl;

    //2. 重复继承
    cout << "Derived size:" << sizeof(Derived) << endl; //8

    return EXIT_SUCCESS;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虚继承可以解决多种继承前面提到的两个问题：</p>
<p>虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，64位8字节/windows 4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类指针依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，<strong>虚基类指针也会被继承。</strong></p>
<p>实际上，<code>vbptr</code>指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<p><img src="05.png" alt></p>
<pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>

using namespace std;


class A  //大小为4
{
public:
    int a;
};

class B:virtual public A{ // vbptr 8, int b 4, int a 4 = 12
public:
    int b;
};

class C:virtual public A{// vbptr 8, int c 4, int a 4 = 12
public:
    int c;
};

class D:public B, public C{
    // int a, b, c, d=16
    // class B  vbptr 4
    // class C  vbptr 4  = 24
public:
    int d;
};

int main()
{
    A a;
    B b;
    C c;
    D d;
    cout << sizeof(a) << endl; // 4 
    cout << sizeof(b) << endl; // 16
    cout << sizeof(c) << endl; // 16
    cout << sizeof(d) << endl; // 24
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>链接:<a href="https://blog.csdn.net/bxw1992/article/details/77726390" target="_blank" rel="noopener">https://blog.csdn.net/bxw1992/article/details/77726390</a></p>
<h2 id="14、虚函数"><a href="#14、虚函数" class="headerlink" title="14、虚函数"></a>14、虚函数</h2><p><strong>问题</strong></p>
<pre><code>父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象。但是由于编译阶段编译器根据对象的指针或者引用选择函数调用，所以会调用父类的函数。

解决问题的方法是迟绑定(动态绑定)，在运行时根据对象的实际类型决定。</code></pre><p><strong>解决</strong></p>
<pre><code>C++动态多态性是通过虚函数来实现的，虚函数允许子类（派生类）重新定义父类（基类）成员函数，而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。

对于特定的函数进行动态绑定，c++要求在基类中声明这个函数的时候使用virtual关键字,动态绑定也就对virtual函数起作用.</code></pre><ul>
<li><p>为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要.</p>
</li>
<li><p>如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的.</p>
</li>
<li><p>在派生类中virtual函数的重定义称为重写(override).</p>
</li>
<li><p>Virtual关键字只能修饰成员函数.</p>
</li>
<li><p>构造函数不能为虚函数</p>
</li>
</ul>
<p><strong>虚函数原理</strong></p>
<p>首先，我们看看编译器如何处理虚函数。当编译器发现我们的类中有虚函数的时候，编译器会创建一张虚函数表（virtual function table ），表中存储着类对象的虚函数地址，并且给类增加一个指针，这个指针就是<code>vpointer</code>(缩写<code>vptr</code>)，这个指针是指向虚函数表。</p>
<p>父类对象包含的指针，指向父类的虚函数表地址，子类对象包含的指针，指向子类的虚函数表地址。</p>
<p>如果子类重新定义了父类的函数，那么函数表中存放的是新的地址，如果子类没有重新定义，那么表中存放的是父类的函数地址。如果子类有自己的虚函数，则只需要添加到表中即可。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class A{
public:
    virtual void func1(){}
    virtual void func2(){}
};

//B类为空，那么大小应该是1字节，实际情况是这样吗？
class B : public A{};

void test(){
    cout << "A size:" << sizeof(A) << endl; // win指针字节为4, linux 64 字节为8
    cout << "B size:" << sizeof(B) << endl; // 4
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>多态的成立条件：</strong></p>
<ul>
<li><p>有继承</p>
</li>
<li><p>子类重写父类虚函数函数</p>
<pre><code>a) 返回值，函数名字，函数参数，必须和父类完全一致(析构函数除外) 

b) 子类中virtual关键字可写可不写，建议写</code></pre></li>
<li><p>类型兼容，父类指针，父类引用指向子类对象</p>
</li>
</ul>
<p><strong>抽象类和纯虚函数</strong></p>
<p>当基类中有至少一个纯虚函数则为抽象类</p>
<ul>
<li><p>纯虚函数使用关键字virtual，并在其后面加上=0。如果试图去实例化一个抽象类，编译器则会阻止这种操作。</p>
</li>
<li><p>当继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。</p>
</li>
<li><p>Virtual void fun() = 0;告诉编译器在vtable中为函数保留一个位置，但在这个特定位置不放地址。</p>
</li>
</ul>
<p><strong>接口类</strong></p>
<p>接口类中只有函数原型定义，没有任何数据定义。多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。</p>
<p>注意:除了析构函数外，其他声明都是纯虚函数。</p>
<p><strong>虚析构函数</strong></p>
<p>虚析构函数是为了解决[基类]的[指针]指向派生类对象，并用基类的指针删除派生类对象。</p>
<p><strong>虚函数和虚继承的异同</strong></p>
<p>在这里我们可以对比虚函数的实现原理：他们有相似之处，都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）。</p>
<p>虚基类指针依旧存在继承类中，只占用存储空间；基类虚函数指针不存在于子类中，不占用存储空间。</p>
<p>虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。</p>
<h2 id="15、函数模板的机制"><a href="#15、函数模板的机制" class="headerlink" title="15、函数模板的机制"></a>15、函数模板的机制</h2><p><strong>函数模板机制结论：</strong></p>
<ul>
<li><p>编译器并不是把函数模板处理成能够处理任何类型的函数</p>
</li>
<li><p>函数模板通过具体类型产生不同的函数</p>
</li>
<li><p>编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
</li>
</ul>
<p><strong>局限性</strong>:</p>
<p>编写的模板函数很可能无法处理某些类型，另一方面，有时候通用化是有意义的，但C++语法不允许这样做。为了解决这种问题，可以提供<strong>模板的重载</strong>，为这些特定的类型提供具体化的模板。</p>
<pre class="line-numbers language-c++"><code class="language-c++">class Person
{
public:
    Person(string name, int age)
    {
        this->mName = name;
        this->mAge = age;
    }
    string mName;
    int mAge;
};


//普通交换函数
template <class T>
void mySwap(T &a,T &b)
{
    T temp = a;
    a = b;
    b = temp;
}


//第三代具体化，显示具体化的原型和定意思以template<>开头，并通过名称来指出类型
//具体化优先于常规模板
template<>void mySwap<Person>(Person &p1, Person &p2)
{
    string nameTemp;
    int ageTemp;

    nameTemp = p1.mName;
    p1.mName = p2.mName;
    p2.mName = nameTemp;

    ageTemp = p1.mAge;
    p1.mAge = p2.mAge;
    p2.mAge = ageTemp;

}

void test()
{
    Person P1("Tom", 10);
    Person P2("Jerry", 20);

    cout << "P1 Name = " << P1.mName << " P1 Age = " << P1.mAge << endl;
    cout << "P2 Name = " << P2.mName << " P2 Age = " << P2.mAge << endl;
    mySwap(P1, P2);
    cout << "P1 Name = " << P1.mName << " P1 Age = " << P1.mAge << endl;
    cout << "P2 Name = " << P2.mName << " P2 Age = " << P2.mAge << endl;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="16、C-类型转换"><a href="#16、C-类型转换" class="headerlink" title="16、C++类型转换"></a>16、C++类型转换</h2><p><strong>静态类型转换static_cast</strong></p>
<ul>
<li><p>用于<a href="http://baike.baidu.com/view/2405425.htm" target="_blank" rel="noopener">类层次结构</a>中基类（父类）和<a href="http://baike.baidu.com/view/535532.htm" target="_blank" rel="noopener">派生类</a>（子类）之间指针或引用的转换。</p>
<ul>
<li><p>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；</p>
</li>
<li><p>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p>
</li>
</ul>
</li>
<li><p>用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。</p>
</li>
</ul>
<p><strong>动态类型转换(dynamic_cast)</strong></p>
<ul>
<li><p>dynamic_cast主要用于类层次间的上行转换和下行转换；</p>
</li>
<li><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</p>
</li>
<li><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全；</p>
</li>
</ul>
<p><strong>常量转换(const_cast)</strong></p>
<p>该运算符用来修改类型的const属性。。</p>
<ul>
<li><p>常量指针被转化成非常量指针，并且仍然指向原来的对象；</p>
</li>
<li><p>常量引用被转换成非常量引用，并且仍然指向原来的对象；</p>
</li>
</ul>
<p><strong>重新解释转换(reinterpret_cast)</strong></p>
<p>这是最不安全的一种转换机制，最有可能出问题。</p>
<p>主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针.</p>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《C和C++语法总结》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/01/03/c-he-c-yu-fa-zong-jie/" property="cc:attributionName"
               rel="cc:attributionURL">
                Ace
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '85f48fa8f84b940f407f',
        clientSecret: 'c88650575ce616c6abfa23b953cc755c9b8e483e',
        repo: '981935539.github.io',
        owner: '981935539',
        admin: 981935539,
        id: '2020/01/03/c-he-c-yu-fa-zong-jie/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2020/01/03/c-he-c-yu-fa-zong-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="C和C++语法总结">
                        
                        <span class="card-title">C和C++语法总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一、C语言篇1、gcc/g++1.1、为什么需要gcc/g++
编辑器(如vi、记事本)是指我用它来写程序的（编辑代码），而我们写的代码语句，电脑是不懂的，我们需要把它转成电脑能懂的语句，编译器就是这样的转化工具。就是说，我们用编辑器编写程
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-01-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category" target="_blank">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/" target="_blank">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                    <a href="/tags/C/" target="_blank">
                        <span class="chip bg-color">C</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/12/30/shen-du-xue-xi-zhi-chao-can-shu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="深度学习之超参数">
                        
                        <span class="card-title">深度学习之超参数</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            一、什么是超参数​    超参数是我们在将学习算法应用于数据集之前需要设置的变量。超参数的一个挑战在于,它不存在适用于所有地方的万能数字,每个任务和数据集的最佳数字各不相同。​    一般来讲, 我们可以将超参数分为两类, 第一类是优化器超
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-12-30
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/深度学习/" class="post-category" target="_blank">
                                    深度学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/DL/" target="_blank">
                        <span class="chip bg-color">DL</span>
                    </a>
                    
                    <a href="/tags/Python/" target="_blank">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 杨青海的博客<br />'
            + '作者: Ace<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019 YangQingHai. All Rights Reserved.

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">37.8k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/981935539" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:981935539@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/981935539" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="https://user.qzone.qq.com/981935539" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://weibo.com/981935539" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 11, 15, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>